# .github/workflows/oss_tests.yml - FINAL FIXED VERSION WITH PROPER YAML
name: OSS Boundary Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

jobs:
  oss-boundary:
    name: OSS Boundary Validation
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: OSS Boundary Validation
      run: |
        echo "ðŸ” OSS BOUNDARY VALIDATION"
        echo "=========================="
        
        # Check 1: Required directories exist
        echo ""
        echo "1. Checking required directories..."
        REQUIRED_DIRS=(
          "agentic_reliability_framework"
          "agentic_reliability_framework/arf_core"
          "agentic_reliability_framework/arf_core/models"
          "agentic_reliability_framework/arf_core/engine"
          "agentic_reliability_framework/arf_core/config"
        )
        
        all_dirs_exist=true
        for dir in "${REQUIRED_DIRS[@]}"; do
          if [ -d "$dir" ]; then
            echo "   âœ… $dir exists"
          else
            echo "   âŒ $dir MISSING"
            all_dirs_exist=false
          fi
        done
        
        if [ "$all_dirs_exist" = false ]; then
          echo "âŒ Missing required OSS directories"
          exit 1
        fi
        
        # Check 2: Required files exist
        echo ""
        echo "2. Checking required files..."
        REQUIRED_FILES=(
          "agentic_reliability_framework/__init__.py"
          "agentic_reliability_framework/arf_core/__init__.py"
          "agentic_reliability_framework/arf_core/constants.py"
          "agentic_reliability_framework/arf_core/models/healing_intent.py"
        )
        
        all_files_exist=true
        for file in "${REQUIRED_FILES[@]}"; do
          if [ -f "$file" ]; then
            echo "   âœ… $file exists"
          else
            echo "   âŒ $file MISSING"
            all_files_exist=false
          fi
        done
        
        if [ "$all_files_exist" = false ]; then
          echo "âŒ Missing required OSS files"
          exit 1
        fi
        
        # Check 3: Smart enterprise code check
        echo ""
        echo "3. Checking for Enterprise code violations..."
        
        # Create a Python script for smart checking - using temp file to avoid YAML heredoc issues
        cat > /tmp/check_enterprise.py << 'SCRIPT_EOF'
import os
import re
import sys

def is_comment_or_string(line):
    """Check if line is a comment or contains only strings"""
    stripped = line.strip()
    
    # Whole line comment
    if stripped.startswith('#'):
        return True
    
    # Check for string assignments (allowed in OSS)
    string_patterns = [
        'ENTERPRISE_UPGRADE_URL',
        'enterprise_features',
        'requires_enterprise',
        'enterprise_metadata',
        'enterprise_edition',
        'EnterpriseMCPServer',  # Can be in strings for documentation
    ]
    
    for pattern in string_patterns:
        if pattern in line and ('"' in line or "'" in line):
            # Check if it's in a string literal
            if '"' + pattern + '"' in line or "'" + pattern + "'" in line:
                return True
    
    return False

def check_file(filepath):
    """Check a single file for Enterprise code violations"""
    violations = []
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        for i, line in enumerate(lines, 1):
            line_stripped = line.rstrip('\n')
            
            # Skip comments and allowed string references
            if is_comment_or_string(line_stripped):
                continue
            
            # Check for problematic patterns
            patterns = [
                # Import statements
                (r'^\s*import\s+.*Enterprise', 'import Enterprise module'),
                (r'^\s*from\s+.*\bEnterprise\b', 'from Enterprise module import'),
                
                # Class definitions
                (r'^\s*class\s+.*Enterprise', 'Enterprise class definition'),
                
                # Function definitions
                (r'^\s*def\s+.*enterprise', 'enterprise function (lowercase)'),
                (r'^\s*def\s+.*Enterprise', 'Enterprise function (uppercase)'),
                
                # Variable usage (not in strings)
                (r'EnterpriseMCPServer\s*(?!=)', 'EnterpriseMCPServer usage'),
                (r'enterprise_mcp_server\s*(?!=)', 'enterprise_mcp_server usage'),
            ]
            
            for pattern, description in patterns:
                if re.search(pattern, line_stripped, re.IGNORECASE):
                    # Additional check: not in a comment
                    if '#' in line_stripped:
                        code_part = line_stripped.split('#')[0]
                        if re.search(pattern, code_part, re.IGNORECASE):
                            violations.append(f"Line {i}: {description} - '{line_stripped.strip()}'")
                    else:
                        violations.append(f"Line {i}: {description} - '{line_stripped.strip()}'")
                    break  # Only report first violation per line
    
    except Exception as e:
        print(f"âš ï¸  Could not check {filepath}: {e}")
    
    return violations

def main():
    arf_core_dir = "agentic_reliability_framework/arf_core"
    all_violations = []
    
    for root, dirs, files in os.walk(arf_core_dir):
        for file in files:
            if file.endswith('.py'):
                filepath = os.path.join(root, file)
                violations = check_file(filepath)
                if violations:
                    all_violations.append((filepath, violations))
    
    if all_violations:
        print("âŒ Enterprise code violations found:")
        print("-" * 60)
        for filepath, violations in all_violations:
            print(f"\nðŸ“ {filepath}:")
            for violation in violations:
                print(f"   â€¢ {violation}")
        print("-" * 60)
        print(f"\nTotal violations: {sum(len(v) for _, v in all_violations)}")
        sys.exit(1)
    else:
        print("âœ… No Enterprise code violations found")
        
        # Quick sanity check: count files checked
        py_files = []
        for root, dirs, files in os.walk(arf_core_dir):
            for file in files:
                if file.endswith('.py'):
                    py_files.append(os.path.join(root, file))
        
        print(f"âœ… Checked {len(py_files)} Python files in arf_core/")
        sys.exit(0)

if __name__ == "__main__":
    main()
SCRIPT_EOF
        
        python3 /tmp/check_enterprise.py
        
        python_exit_code=$?
        
        if [ $python_exit_code -ne 0 ]; then
            echo "âŒ Enterprise code violations detected"
            exit 1
        fi
        
        # Check 4: Can import basic OSS module
        echo ""
        echo "4. Testing basic OSS imports..."
        python3 -c "
import sys
try:
    # Test 1: Main package import
    import agentic_reliability_framework as arf
    print('   âœ… Successfully imported agentic_reliability_framework')
    print(f'   Version: {arf.__version__}')
    
    # Test 2: OSS constants
    from agentic_reliability_framework.arf_core import constants
    print(f'   âœ… OSS constants: {constants.OSS_EDITION}')
    print(f'   License: {constants.OSS_LICENSE}')
    
    # Test 3: OSS models
    from agentic_reliability_framework.arf_core.models import healing_intent
    print('   âœ… OSS healing_intent module available')
    
    # Test 4: OSS MCP client
    try:
        from agentic_reliability_framework.arf_core.engine.simple_mcp_client import OSSMCPClient
        print('   âœ… OSS MCP client available')
    except ImportError:
        from agentic_reliability_framework.arf_core.engine.oss_mcp_client import OSSMCPClient
        print('   âœ… OSS MCP client available (alternative)')
    
    print('')
    print('ðŸŽ‰ All OSS imports working correctly!')
    
except ImportError as e:
    print(f'   âŒ Import failed: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
except Exception as e:
    print(f'   âš ï¸  Other error: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
        "
        
        echo ""
        echo "=========================================="
        echo "ðŸŽ‰ OSS BOUNDARY VALIDATION PASSED!"
        echo "=========================================="
        echo "âœ“ All required directories exist"
        echo "âœ“ All required files exist"
        echo "âœ“ No Enterprise code violations"
        echo "âœ“ All OSS imports work correctly"
        echo "âœ“ OSS edition is clean and functional"
